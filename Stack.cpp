#include "Stack.h"

Stack::Stack() : head{ nullptr } {}

// очистка списка
void Stack::Clear()
{
	head = nullptr;
}

// проверка на пустоту
bool Stack::IsEmpty()
{
	return head == nullptr;
}

//возвращает количество элементов, как и в обычном стеке
int Stack::GetCount()
{
	int size = 0;
	Node* curr = head;
	while (curr != nullptr)
	{
		size++;
		curr = curr->next;
	}
	return size;
}

// пуш и поп работают по принципу LIFO то есть элемент
// попадает в самое начало и занимает место указателя хеда
// а при извлечении извлекается хед и происходит смещение
// этого указателя на 1 вперед (т.к. я не очень поняла в каком
// именно смысле нужно было модифицировать стек под список, я
// нашла статью и почитав примерно поняла что требуется и сделала
// с помощью того, что поняла из статьи
// https://www.geeksforgeeks.org/implement-a-stack-using-singly-linked-list/
// разве что мне лень было изучать реализацию в статье и я увидела
// её только сейчас, поэтому надеюсь сделала правильно

void Stack::Push(int c)
{
	Node* newnode = new Node{ c };
	newnode->next = head;
	head = newnode;
}

// также как и в гет каунт, но происходит не прибавка, а
// вывод инфы из дата

void Stack::Print()
{
	Node* curr = head;
	while (curr != nullptr)
	{
		cout << curr->data << ' ';
		curr = curr->next;
	}
}

// возвращается хед,после чего происходит его смещение
// (возвращается неконстанта, но перед возвращением 
// нексту передается нулевой указатель для безопасности

Node* Stack::Pop()
{
	Node* returnin = head;
	head = head->next;
	returnin->next = nullptr;
	return returnin;
}

Node* Stack::Copy()
{
	// стек (необходим для использования методов, из-за чего и был создан
	// вместо простого нода*)
	Stack copycat;
	Node* curr = head;
	// так как запись происходит с помощью LIFO, к примеру
	// при записи массива содержащего 1 2 3 4 в список при выводе
	// мы получим 4321, из чего следует что сначала нам необходимо записать
	// их в обратном порядке в массив, а уже после передать в копикет список
	// ведь если мы сделаем это напрямую, то вместо точной копии, которая должна
	// будет быть равной 4321, мы получим 1234
	int* mass_buff = new int[GetCount()];
	// индекс для начала записи с конца буфферного массива
	int indx = GetCount()-1;
	while (curr != nullptr)
	{
		// убавление индекса и присваивание массиву списка
		mass_buff[indx--] = curr->data;
		curr = curr->next;
	}
	curr = head;
	// наконец-то передача в список значений из массива
	for(int i = 0; i< GetCount();i++)
	{
		copycat.Push(mass_buff[i]);
	}
	// возвращение атрибута хед из копикета
	return copycat.head;
}

Node* Stack::operator+(Stack obj)
{
	// стек который будет содержать элементы обоих списков
	// опять же сздан для удобства вместо простого буферного узла
	Stack plus;
	// копируем в хед список из левого операнда +
	plus.head = Copy();
	Node* curr = plus.head;
	// идём по кьюренту пока не дойдём до последнего элемента у которого
	// нет следующего в нексте
	while (curr->next != nullptr)
	{
		curr = curr->next;
	}

	// копируем в некст последнего элемента обьекты правого операнда
	curr->next = obj.Copy();

	// возвращаем хед от плюса
	return plus.head;
}

Node* Stack::operator*(Stack obj)
{
	// уже понятно, что он для удобства думаю
	Stack mult;
	// тут я решила использовать библиотеку и шаблонный класс вектор
	// тут такое дело, что когда я пыталась создать дин. массив для записи общих чисел
	// я не могла определить сколько ЗАПОЛНЕННЫХ (не мусором) ячеек в массиве
	// и в итоге при передаче в список мульт я делала это в цикле с импользованием
	// размера массива, указанного при инициализации и в итоге даже если из
	// условных 10 выделенных ячеек была заполнена только 1, в мульт попадал весь
	// мусор, ведь я не могла определить какое количество заполненных ячеек в массиве чтобы
	// записать в цикл (сайзоф не помогал, были какие-то несостыковки)
	// поэтому я вспомнила о классе вектор и почитав о нем поняла, что можно создать его
	// без выделения памяти и он при необходимости сам будет расширяться, а аткже у него просто 
	// достать его размер, поэтому было решено использовать его

	// я также понимаю, что возникает вопрос почему я не создала ещё 1 список для этого,
	// но я не хтела заморачиваться с написанием перегрузки оператора [] для цикла ниже
	// который предотвращает запись повторых значений, поэтому решила использовать вектор
	// с уже встроенной перегрузкой, да и не помешает научиться с ним работать

	vector<int> shared;
	// два кьюрента с хедом левого и правого операндов
	Node* curr1 = head, * curr2 = obj.head;
	// каунтер для проверки повторок в векторе
	int repeat_count = 0;

	while(curr1!=nullptr)
	{
		while(curr2!=nullptr)
		{
			if (curr1->data == curr2->data)
			{
				// проверка на то, чтобы при нахождении общего элемента
				// его ещё не было в векторе, чтобы исключить повторки
				for (int i = 0; i < shared.size(); i++)
				{
					if (curr1->data == shared[i])
					{
						// если повторки есть, каунтер будет больше 0
						repeat_count++;
					}
				}
				// если повторок нет, идет запись в вектор
				if (repeat_count == 0)
				{
					shared.push_back(curr1->data);
				}
			}
			curr2 = curr2->next;
		}
		// обнуление каунта
		repeat_count = 0;
		// обнуление кьюрента правого операнда
		curr2 = obj.head;
		curr1 = curr1->next;
	}

	// запись из вектора в мульт
	for (int i = 0; i < shared.size(); i++)
	{
		mult.Push(shared[i]);
	}

	// возвращение хеда мульта
	return mult.head;
}